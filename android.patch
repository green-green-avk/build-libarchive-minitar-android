--- libarchive/archive_write_disk_posix.c	2019-12-29 17:39:54.000000000 -0800
+++ libarchive/archive_write_disk_posix.c	2020-01-27 17:16:17.978059447 -0800
@@ -2144,8 +2144,8 @@
 	if (en) {
 		/* Everything failed; give up here. */
 		if ((&a->archive)->error == NULL)
-			archive_set_error(&a->archive, en, "Can't create '%s'",
-			    a->name);
+			archive_set_error(&a->archive, en, "Can't create '%s', errno = %d",
+			    a->name, en);
 		return (ARCHIVE_FAILED);
 	}
 
@@ -2171,6 +2171,10 @@
 	struct archive_string error_string;
 	int error_number;
 
+	/* Nonrooted Android can't do hard links! */
+	/* Just pretend they are symlinks. */
+#ifndef IS_ANDROID_NOROOT
+
 	/* We identify hard/symlinks according to the link names. */
 	/* Since link(2) and symlink(2) don't handle modes, we're done here. */
 	linkname = archive_entry_hardlink(a->entry);
@@ -2181,7 +2185,7 @@
 		archive_string_init(&error_string);
 		linkname_copy = strdup(linkname);
 		if (linkname_copy == NULL) {
-		    return (EPERM);
+			return (ENOMEM);
 		}
 		/*
 		 * TODO: consider using the cleaned-up path as the link
@@ -2216,6 +2220,9 @@
 		free(linkname_copy);
 		archive_string_free(&error_string);
 		r = link(linkname, a->name) ? errno : 0;
+		if (r != 0)
+			archive_set_error(&a->archive, ARCHIVE_FAILED, "Can't create hard link '%s', errno = %d",
+			    a->name, r);
 		/*
 		 * New cpio and pax formats allow hardlink entries
 		 * to carry data, so we may have to open the file
@@ -2251,9 +2258,18 @@
 #endif
 	}
 	linkname = archive_entry_symlink(a->entry);
+#else
+	linkname = archive_entry_symlink(a->entry);
+	if (linkname == NULL)
+		linkname = archive_entry_hardlink(a->entry);
+#endif
 	if (linkname != NULL) {
 #if HAVE_SYMLINK
-		return symlink(linkname, a->name) ? errno : 0;
+		r = symlink(linkname, a->name) ? errno : 0;
+		if (r != 0)
+			archive_set_error(&a->archive, ARCHIVE_FAILED, "Can't create symlink '%s', errno = %d",
+			    a->name, r);
+		return (r);
 #else
 		return (EPERM);
 #endif
